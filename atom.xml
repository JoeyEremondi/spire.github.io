<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Spire Language Development Blog]]></title>
  <link href="http://spire-lang.org/atom.xml" rel="self"/>
  <link href="http://spire-lang.org/"/>
  <updated>2014-08-05T21:15:33-07:00</updated>
  <id>http://spire-lang.org/</id>
  <author>
    <name><![CDATA[Larry Diehl]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Inductive-Recursive Descriptions]]></title>
    <link href="http://spire-lang.org/blog/2014/08/04/inductive-recursive-descriptions/"/>
    <updated>2014-08-04T19:52:32-07:00</updated>
    <id>http://spire-lang.org/blog/2014/08/04/inductive-recursive-descriptions</id>
    <content type="html"><![CDATA[<p>This post is about adapting descriptions, used to encode dependently typed
datatypes (including type families) originally in
<a href="http://gallium.inria.fr/~pdagand/papers/levitation.pdf">The Gentle Art of Levitation</a>,
to inductive-recursive types.</p>

<!-- more -->


<h2>Goals</h2>

<p>There have been many encodings of [indexed] inductive-recursive types,
but as I developed Spire I came to desire an encoding that satisfied all
of the following criteria:</p>

<ul>
<li><strong>Is universe-polymorphic.</strong> Although it&rsquo;s not hard to add universe
levels, it is crucial for an actual language implementation. Nevertheless, most
papers (justifiably) abstain from cluttering their presentation with
universe levels.</li>
<li><strong>Passes Agda&rsquo;s termination &amp; positivity checkers.</strong>
Many alternative encodings of IR types, especially the ones that
are
<a href="https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-mscs11.pdf">directly inspired by algebraic semantics [Ghani &amp; Hancock]</a>
suffer from being too general to pass Agda&rsquo;s termination or positivity
checkers.</li>
<li><strong>Has description constructors that directly correspond to
constructor declaration arguments.</strong>
Implementing a high-level language that translates to a canonical
kernel language is very difficult if the kernel language is too
different from the high-level language. For this reason I have chosen
to make the description (<code>Desc</code>) datatype enforce structure that is as
similar to a higher-level constructor telescope declaration as
possible. From the descriptions literature, this means extending the
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.pdf">propositional encoding [McBride]</a>
rather than the (albeit more general)
<a href="http://gallium.inria.fr/~pdagand/stuffs/thesis-2011-phd/thesis.pdf">computational encoding [Dagand]</a>.
From the IR literature, this means staying away from the more semantic
encodings described by
<a href="https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-mscs11.pdf">Ghani &amp; Hancock</a>,
as well as subtle differences from the original encoding by Dybjer and
Setzer encoding, as reviewed by
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/SmallIR/SmallIR.pdf">Malatesta et. al.</a>.</li>
<li><strong>Has an induction principle.</strong>
The induction principle for datatypes encoded in the IR literature is
typically given, but elimination principles are only sometimes given.
I also wanted a principle in the style of the description literature.</li>
</ul>


<h2>Non-Indexed Inductive-Recursive Descriptions</h2>

<p>I&rsquo;m going to start with descriptions for non-indexed IR types, and move to
indexed IR types in the subsequent section. Additionally, I will mainly
focus on the definition of descriptions, and encoding types with
descriptions. The harder part is defining the fixpoint for encoded types
and the corresponding induction principle, which I briefly gloss over
at the end of the post. Additionally, all the code presented in this
post is linked to in the conclusion.</p>

<p>A common use of IR is to
model a dependently typed language. Below is the definition of an
example language. The datatype definition (<code>Lang</code>) is mutually defined
with an interpretation function whose domain is <code>Set</code>. Because the
codomain is <code>Set</code> (rather than some small type like <code>ℕ</code>), this makes
it a <em>large</em> inductive-recursive definition.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="nf">mutual</span>
</span><span class='line'>  <span class="kr">data</span> <span class="kt">Lang</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>    <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Two</span> <span class="kt">:</span> <span class="kt">Lang</span>
</span><span class='line'>    <span class="kt">Pair</span> <span class="kt">Fun</span> <span class="kt">Tree</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Lang</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="err">⟦</span> <span class="kt">A</span> <span class="err">⟧</span> <span class="err">→</span> <span class="kt">Lang</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Lang</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">⟦</span><span class="kr">_</span><span class="err">⟧</span> <span class="kt">:</span> <span class="kt">Lang</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">Zero</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="err">⊥</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">One</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="err">⊤</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">Two</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">Pair</span> <span class="kt">A</span> <span class="kt">B</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="err">⟦</span> <span class="kt">A</span> <span class="err">⟧</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="err">⟦</span> <span class="kt">B</span> <span class="n">a</span> <span class="err">⟧</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">Fun</span> <span class="kt">A</span> <span class="kt">B</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="err">⟦</span> <span class="kt">A</span> <span class="err">⟧</span><span class="p">)</span> <span class="err">→</span> <span class="err">⟦</span> <span class="kt">B</span> <span class="n">a</span> <span class="err">⟧</span>
</span><span class='line'>  <span class="err">⟦</span> <span class="kt">Tree</span> <span class="kt">A</span> <span class="kt">B</span> <span class="err">⟧</span> <span class="ow">=</span> <span class="kt">W</span> <span class="err">⟦</span> <span class="kt">A</span> <span class="err">⟧</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="err">⟦</span> <span class="kt">B</span> <span class="n">a</span> <span class="err">⟧</span>
</span></code></pre></td></tr></table></div></figure>


<p>I will encode <code>Lang</code> using the following description datatype
(<code>Desc</code>). <code>Desc</code> is parameterized by a datatype <code>O</code>, which is the type
of the codomain of the IR interpretation function.
It is easiest to think of the constructors of <code>Desc</code> as the pieces
used to form the telescope of a constructor type declaration, such as
<code>Two</code> and <code>Pair</code> in <code>Lang</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="kr">data</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="p">{</span><span class="n">ℓ</span><span class="err">′</span><span class="p">}</span> <span class="p">(</span><span class="kt">O</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="err">′</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">lsuc</span> <span class="n">ℓ</span> <span class="err">⊔</span> <span class="n">ℓ</span><span class="err">′</span><span class="p">)</span>  <span class="kr">where</span>
</span><span class='line'>  <span class="kt">End</span> <span class="kt">:</span> <span class="p">(</span><span class="n">o</span> <span class="kt">:</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Rec</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">O</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Ref</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="p">(</span><span class="n">o</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Arg</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="n">ℓ</span> <span class="kt">O</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>End</code> ends a constructor declaration, and specifies what the
mutually-defined IR interpretation function returns for the
constructor. <code>Rec</code> encodes a request for a recursive first-order
argument, and the remainder of the telescope may depend on the
interpretation function applied to this recursive argument.
<code>Ref</code> encodes a request for a recursive function argument. To remain
strictly positive, <code>Ref</code> asks for the type of the domain of the
function argument, and the remainder of the telescope may depend on a
function from a value of the domain of the function to the
interpretation function applied to the result of the recursive function
that <code>Ref</code> encodes.
<code>Arg</code> records an ordinary argument by requesting the type of the
argument, and the remainder of the telescope may depend on a value of
that type.</p>

<p>Below is the encoding of the the <code>Lang</code> datatype, and its
interpretation function, as a description.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="kr">data</span> <span class="kt">LangT</span> <span class="p">{</span><span class="n">ℓ</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span> <span class="kr">where</span>
</span><span class='line'>  <span class="kt">ZeroT</span> <span class="kt">OneT</span> <span class="kt">TwoT</span> <span class="kt">PairT</span> <span class="kt">FunT</span> <span class="kt">TreeT</span> <span class="kt">:</span> <span class="kt">LangT</span>
</span><span class='line'>
</span><span class='line'><span class="kt">LangD</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">lzero</span><span class="p">)</span>
</span><span class='line'><span class="kt">LangD</span> <span class="ow">=</span> <span class="kt">Arg</span> <span class="kt">LangT</span> <span class="n">λ</span>
</span><span class='line'>  <span class="p">{</span> <span class="kt">ZeroT</span> <span class="err">→</span> <span class="kt">End</span> <span class="err">⊥</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">OneT</span> <span class="err">→</span> <span class="kt">End</span> <span class="err">⊤</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">TwoT</span> <span class="err">→</span> <span class="kt">End</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">PairT</span> <span class="err">→</span> <span class="kt">Rec</span> <span class="n">λ</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">Lift</span> <span class="kt">A</span><span class="p">)</span> <span class="n">λ</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">End</span> <span class="p">(</span><span class="kt">Σ</span> <span class="kt">A</span> <span class="p">(</span><span class="kt">B</span> <span class="err">∘</span> <span class="n">lift</span><span class="p">))</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">FunT</span> <span class="err">→</span> <span class="kt">Rec</span> <span class="n">λ</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">Lift</span> <span class="kt">A</span><span class="p">)</span> <span class="n">λ</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">End</span> <span class="p">((</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">B</span> <span class="p">(</span><span class="n">lift</span> <span class="n">a</span><span class="p">))</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">TreeT</span> <span class="err">→</span> <span class="kt">Rec</span> <span class="n">λ</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">Lift</span> <span class="kt">A</span><span class="p">)</span> <span class="n">λ</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">End</span> <span class="p">(</span><span class="kt">W</span> <span class="kt">A</span> <span class="p">(</span><span class="kt">B</span> <span class="err">∘</span> <span class="n">lift</span><span class="p">))</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>Two</code> constructor takes no arguments, and its interpretation
function returns the <code>Bool</code> type, and the <code>Zero</code> and <code>One</code> cases are
similar.
The <code>Pair</code> constructor first takes a
recursive argument, so the rest of the telescope can depend on its
interpretation. Then, it takes a recursive function argument whose
domain is the interpretation of the first argument. Once again, the
remainder of the telescope may depend on the the <em>function</em> from the
requested domain to the interpretation function result. Finally, the
constructor declaration ends by saying that the interpretation of
<code>Pair</code> as a whole is the sigma type (<code>Σ</code>) that we expect. The <code>Fun</code>
and <code>Tree</code> constructors are encoded in the same way that <code>Pair</code> is.
Also, I sprinkle <code>Lift</code> and <code>lift</code> in the right places to make the
universe levels work out.</p>

<p>Another standard example of a <em>small</em> inductive-recursive definition
is an interpreter of an arithmetic language, as presented by
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/SmallIR/SmallIR.pdf">Malatesta et. al.</a>.
The idea is to express mathematical sums and products, where the
domain of the sum or product specifies the bound on the iteration. See
the paper for an in depth explanation, but below is the high-level
code for the <code>Arith</code> type.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="nf">sum</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">ℕ</span>
</span><span class='line'><span class="nf">sum</span> <span class="n">zero</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class='line'><span class="nf">sum</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">n</span> <span class="p">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">suc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">prod</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">ℕ</span>
</span><span class='line'><span class="nf">prod</span> <span class="n">zero</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">suc</span> <span class="n">zero</span>
</span><span class='line'><span class="nf">prod</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="o">*</span> <span class="n">prod</span> <span class="n">n</span> <span class="p">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">suc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mutual</span>
</span><span class='line'>  <span class="kr">data</span> <span class="kt">Arith</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>    <span class="kt">Num</span> <span class="kt">:</span> <span class="kt">ℕ</span> <span class="err">→</span> <span class="kt">Arith</span>
</span><span class='line'>    <span class="kt">Sum</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Arith</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">eval</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Arith</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Arith</span>
</span><span class='line'>    <span class="kt">Prod</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Arith</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="p">(</span><span class="n">eval</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Arith</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Arith</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">eval</span> <span class="kt">:</span> <span class="kt">Arith</span> <span class="err">→</span> <span class="kt">ℕ</span>
</span><span class='line'>  <span class="n">eval</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span>
</span><span class='line'>  <span class="n">eval</span> <span class="p">(</span><span class="kt">Sum</span> <span class="kt">A</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">eval</span> <span class="kt">A</span><span class="p">)</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="n">sum</span> <span class="p">(</span><span class="n">toℕ</span> <span class="n">a</span><span class="p">)</span> <span class="n">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="n">eval</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">inject</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'>  <span class="n">eval</span> <span class="p">(</span><span class="kt">Prod</span> <span class="kt">A</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">prod</span> <span class="p">(</span><span class="n">eval</span> <span class="kt">A</span><span class="p">)</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="n">sum</span> <span class="p">(</span><span class="n">toℕ</span> <span class="n">a</span><span class="p">)</span> <span class="n">λ</span> <span class="n">b</span> <span class="err">→</span> <span class="n">eval</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">inject</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nf">sum</span><span class="o">-</span><span class="n">lt</span><span class="o">-</span><span class="mi">5</span> <span class="kt">:</span> <span class="kt">Arith</span>
</span><span class='line'><span class="nf">sum</span><span class="o">-</span><span class="n">lt</span><span class="o">-</span><span class="mi">5</span> <span class="ow">=</span> <span class="kt">Sum</span> <span class="p">(</span><span class="kt">Num</span> <span class="mi">5</span><span class="p">)</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">Num</span> <span class="p">(</span><span class="n">toℕ</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">test</span><span class="o">-</span><span class="n">eval</span> <span class="kt">:</span> <span class="n">eval</span> <span class="n">sum</span><span class="o">-</span><span class="n">lt</span><span class="o">-</span><span class="mi">5</span> <span class="err">≡</span> <span class="mi">10</span>
</span><span class='line'><span class="nf">test</span><span class="o">-</span><span class="n">eval</span> <span class="ow">=</span> <span class="n">refl</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note the that it is a <em>small</em> IR type because the codomain of the
interpretation function is a small type (<code>ℕ</code>). Below is the Desc encoding,
which is very similar to what Malatesta et. al. give.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="nf">sum</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">ℕ</span>
</span><span class='line'><span class="nf">sum</span> <span class="n">zero</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class='line'><span class="nf">sum</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">n</span> <span class="p">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">suc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">prod</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="kt">ℕ</span>
</span><span class='line'><span class="nf">prod</span> <span class="n">zero</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">suc</span> <span class="n">zero</span>
</span><span class='line'><span class="nf">prod</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">zero</span> <span class="o">*</span> <span class="n">prod</span> <span class="n">n</span> <span class="p">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">suc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">ArithT</span> <span class="p">{</span><span class="n">ℓ</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span> <span class="kr">where</span>
</span><span class='line'>  <span class="kt">NumT</span> <span class="kt">SumT</span> <span class="kt">ProdT</span> <span class="kt">:</span> <span class="kt">ArithT</span>
</span><span class='line'>
</span><span class='line'><span class="kt">ArithD</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">ℕ</span>
</span><span class='line'><span class="kt">ArithD</span> <span class="ow">=</span> <span class="kt">Arg</span> <span class="kt">ArithT</span> <span class="n">λ</span>
</span><span class='line'>  <span class="p">{</span> <span class="kt">NumT</span> <span class="err">→</span> <span class="kt">Arg</span> <span class="kt">ℕ</span> <span class="n">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">End</span> <span class="n">n</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">SumT</span> <span class="err">→</span> <span class="kt">Rec</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">Fin</span> <span class="n">a</span><span class="p">)</span> <span class="n">λ</span> <span class="n">f</span> <span class="err">→</span> <span class="kt">End</span> <span class="p">(</span><span class="n">sum</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>  <span class="p">;</span> <span class="kt">ProdT</span> <span class="err">→</span> <span class="kt">Rec</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">Fin</span> <span class="n">a</span><span class="p">)</span> <span class="n">λ</span> <span class="n">f</span> <span class="err">→</span> <span class="kt">End</span> <span class="p">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Indexed Inductive-Recursive Descriptions</h2>

<p>Both the <code>Lang</code> and <code>Arith</code> types had interpretations whose codomain
was some constant value (<code>Set</code> and <code>ℕ</code> respectively). More generally,
an inductive-recursive type may be indexed, and the codomain of the
interpretation function may also be a type family. For example, you can
imagine a type like <code>Type : ℕ → Set</code> where the index type is <code>I = ℕ</code>,
and an interpretation function <code>eval : (n : ℕ) → Type n → Fin n</code> where
the interpretation type is <code>O = Fin</code>.</p>

<p>Below is the description type <code>Desc</code> modified to be able to encode
indexed inductive-recursive definitions. It now takes an
index type (<code>(I : Set ℓ)</code>) as an additional parameter to the
(now dependent) interpretation type (<code>(O : I → Set ℓ)</code>).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="kr">data</span> <span class="kt">Desc</span> <span class="p">{</span><span class="n">ℓ</span><span class="p">}</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="kt">O</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">lsuc</span> <span class="n">ℓ</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>  <span class="kt">End</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span> <span class="kt">:</span> <span class="kt">O</span> <span class="n">i</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Rec</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">O</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Ref</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="p">(</span><span class="n">o</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">O</span> <span class="p">(</span><span class="n">i</span> <span class="n">a</span><span class="p">))</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span>
</span><span class='line'>  <span class="kt">Arg</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span>
</span></code></pre></td></tr></table></div></figure>


<p>The new <code>Desc</code> is a mixture of the old one (which is a slightly modified
Dybjer-Setzer IR type) , and the indexed description by
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.pdf">McBride</a>.
Recall that descriptions encode constructor argument telescopes. At
the end of a telescope (<code>End</code>), we must now specify what index the type is
at, as well as the (dependent) value that the interpretation function
returns for the constructor being defined. A recursive (<code>Rec</code>)
argument requires the index at for the requested recursive type, and
the remainder of the telescope of arguments may use the (dependent)
result of the interpretation function. A recursive function argument
(<code>Ref</code>) requires the type of the domain of the recursive argument, an
index value (<code>I</code>) assuming the requested argument (<code>A</code>), and the rest
of the constructor arguments telescope may depend on a <em>function</em> from
the requested argument to the (dependent) interpretation function
call. Finally, requesting an ordinary argument (<code>Arg</code>) is just as
before.</p>

<p>So far we have only looked at descriptions, but they are relatively
useless and easy to get wrong if you haven&rsquo;t defined the corresponding
fixpoint type (which interprets a description of a type as an actual
type). First let&rsquo;s look at <code>El</code>, which interprets a description as a
functor between indexed families of sets.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="kt">El</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="p">(</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="kt">Y</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="err">→</span> <span class="kt">X</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">O</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span>
</span><span class='line'><span class="kt">El</span> <span class="p">(</span><span class="kt">End</span> <span class="n">j</span> <span class="n">o</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">j</span> <span class="err">≡</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="p">(</span><span class="kt">Rec</span> <span class="n">j</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="p">(</span><span class="kt">X</span> <span class="n">j</span><span class="p">)</span> <span class="n">λ</span> <span class="n">x</span> <span class="err">→</span> <span class="kt">El</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="kt">Y</span> <span class="n">x</span><span class="p">))</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="p">(</span><span class="kt">Ref</span> <span class="kt">A</span> <span class="n">j</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="p">((</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">X</span> <span class="p">(</span><span class="n">j</span> <span class="n">a</span><span class="p">))</span> <span class="n">λ</span> <span class="n">f</span> <span class="err">→</span> <span class="kt">El</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">Y</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)))</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="p">(</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="kt">A</span> <span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">El</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>El</code> gets an additional argument (<code>Y</code>), representing the interpretation
function of the described datatype. To define <code>El</code>, we must use <code>Y</code> wherever
we need to get the description from the codomain (<code>B</code>) of a recursive
first-order (<code>Rec</code>) or higher-order (<code>Ref</code>) argument.</p>

<p>More interestingly, we can now define the fixpoint datatype <code>μ</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="nf">mutual</span>
</span><span class='line'>  <span class="kr">data</span> <span class="n">μ</span> <span class="p">{</span><span class="n">ℓ</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">init</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">D</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">D</span><span class="p">)</span> <span class="n">i</span> <span class="err">→</span> <span class="n">μ</span> <span class="kt">D</span> <span class="n">i</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">foldO</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="kt">O</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="n">μ</span> <span class="kt">D</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">O</span> <span class="n">i</span>
</span><span class='line'>  <span class="n">foldO</span> <span class="kt">D</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldsO</span> <span class="kt">D</span> <span class="kt">D</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">foldsO</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="kt">O</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">}</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">E</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="err">→</span> <span class="kt">El</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">E</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span><span class="p">)</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">O</span> <span class="n">i</span>
</span><span class='line'>  <span class="n">foldsO</span> <span class="p">(</span><span class="kt">End</span> <span class="n">j</span> <span class="n">o</span><span class="p">)</span> <span class="kt">E</span> <span class="n">refl</span> <span class="ow">=</span> <span class="n">o</span>
</span><span class='line'>  <span class="n">foldsO</span> <span class="p">(</span><span class="kt">Rec</span> <span class="n">j</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldsO</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span> <span class="n">x</span> <span class="p">))</span> <span class="kt">E</span> <span class="n">xs</span>
</span><span class='line'>  <span class="n">foldsO</span> <span class="p">(</span><span class="kt">Ref</span> <span class="kt">A</span> <span class="n">j</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="p">(</span><span class="n">f</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldsO</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="n">foldO</span> <span class="kt">E</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)))</span> <span class="kt">E</span> <span class="n">xs</span>
</span><span class='line'>  <span class="n">foldsO</span> <span class="p">(</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldsO</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">E</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>


<p>I tried to define this a couple of years ago but stuck for some
reason. I tried once again a couple of days ago and arrived at this
definition. In the IR literature <code>El</code> is
<a href="https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-mscs11.pdf">sometimes referred to</a> as
<code>⟦_⟧₀</code>, and a more general version of <code>foldsO</code> is referred to as
<code>⟦_⟧₁</code>. However, to get <code>foldO</code> to pass Agda&rsquo;s termination check we must inline a
mutually defined specialized version of <code>⟦_⟧₁</code>, namely <code>foldsO</code>. This
is basically the same trick used to get the elimination principle
<code>ind</code> to terminate by inlining <code>hyps</code>. I remember trying to reuse this
termination technique a couple
of years ago and failing, but anyhow there it is.</p>

<p>Finally, for the sake of completeness below is the adapted definition
of <code>Hyps</code> (a collection of inductive hypotheses), <code>ind</code> (the primitive
induction principle for described types), and <code>hyps</code> (a specialized
mapping function to collect inductive hypotheses).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Haskell'><span class='line'><span class="kt">Hyps</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span> <span class="p">(</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="kt">Y</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="err">→</span> <span class="kt">X</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">O</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="p">{</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">}</span> <span class="err">→</span> <span class="kt">X</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">D</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="n">i</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span>
</span><span class='line'><span class="kt">Hyps</span> <span class="p">(</span><span class="kt">End</span> <span class="n">j</span> <span class="n">o</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">q</span> <span class="ow">=</span> <span class="kt">Lift</span> <span class="err">⊤</span>
</span><span class='line'><span class="kt">Hyps</span> <span class="p">(</span><span class="kt">Rec</span> <span class="n">j</span> <span class="kt">D</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="p">(</span><span class="kt">P</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="kt">Hyps</span> <span class="p">(</span><span class="kt">D</span> <span class="p">(</span><span class="kt">Y</span> <span class="n">x</span><span class="p">))</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span><span class="p">)</span>
</span><span class='line'><span class="kt">Hyps</span> <span class="p">(</span><span class="kt">Ref</span> <span class="kt">A</span> <span class="n">j</span> <span class="kt">D</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="p">(</span><span class="n">f</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Σ</span> <span class="p">((</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="p">(</span><span class="n">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="kt">Hyps</span> <span class="p">(</span><span class="kt">D</span> <span class="p">(</span><span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">Y</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)))</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span><span class="p">)</span>
</span><span class='line'><span class="kt">Hyps</span> <span class="p">(</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Hyps</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">----------------------------------------------------------------------</span>
</span><span class='line'>
</span><span class='line'><span class="nf">ind</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="err">→</span> <span class="n">μ</span> <span class="kt">D</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">α</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">D</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">D</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">ihs</span> <span class="kt">:</span> <span class="kt">Hyps</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">D</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">D</span><span class="p">)</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">}</span>
</span><span class='line'>  <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">μ</span> <span class="kt">D</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="err">→</span> <span class="kt">P</span> <span class="n">x</span>
</span><span class='line'>
</span><span class='line'><span class="nf">hyps</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">ℓ</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">}</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">E</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span> <span class="kt">O</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="err">→</span> <span class="n">μ</span> <span class="kt">E</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">Set</span> <span class="n">ℓ</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">α</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">E</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">E</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">ihs</span> <span class="kt">:</span> <span class="kt">Hyps</span> <span class="kt">E</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">E</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span><span class="p">)</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">}</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">E</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Hyps</span> <span class="kt">D</span> <span class="p">(</span><span class="n">μ</span> <span class="kt">E</span><span class="p">)</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span><span class="p">)</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'><span class="nf">ind</span> <span class="kt">D</span> <span class="kt">P</span> <span class="n">α</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">α</span> <span class="n">xs</span> <span class="p">(</span><span class="n">hyps</span> <span class="kt">D</span> <span class="kt">D</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">xs</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">hyps</span> <span class="p">(</span><span class="kt">End</span> <span class="n">i</span> <span class="n">o</span><span class="p">)</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">q</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">hyps</span> <span class="p">(</span><span class="kt">Rec</span> <span class="n">i</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ind</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">x</span> <span class="p">,</span> <span class="n">hyps</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="n">foldO</span> <span class="kt">E</span> <span class="n">x</span><span class="p">))</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">xs</span>
</span><span class='line'><span class="nf">hyps</span> <span class="p">(</span><span class="kt">Ref</span> <span class="kt">A</span> <span class="n">i</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="p">(</span><span class="n">f</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="n">ind</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="p">,</span> <span class="n">hyps</span> <span class="p">(</span><span class="kt">B</span> <span class="p">(</span><span class="n">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="n">foldO</span> <span class="kt">E</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)))</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">xs</span>
</span><span class='line'><span class="nf">hyps</span> <span class="p">(</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">hyps</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">E</span> <span class="kt">P</span> <span class="n">α</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Conclusion</h2>

<p>Well there it is, indexed inductive-recursive descriptions that
satisfy all of my goals stated at the beginning of the post! The
beginning of the post was background on non-indexed IR encoding.
However, the useful bit of the code to reuse is in the previous
section, which includes the universe-polymorphic, indexed,
inductive-recursive, constructor-esque descriptions, as well as their primitive
introduction and elimination rules.</p>

<p>The code used throughout the post is linked below:</p>

<ul>
<li><a href="https://github.com/spire/spire.github.io/blob/source/source/_code/2014-08-04-inductive-recursive-descriptions/IR.agda">Declared Non-Indexed IR</a></li>
<li><a href="https://github.com/spire/spire.github.io/blob/source/source/_code/2014-08-04-inductive-recursive-descriptions/DescIR.agda">Encoded Non-Indexed IR</a></li>
<li><a href="https://github.com/spire/spire.github.io/blob/source/source/_code/2014-08-04-inductive-recursive-descriptions/IDescIR.agda">Encoded Indexed IR</a></li>
</ul>


<p>If you want some homework, try inventing your own indexed
inductive-recursive type, and encode it both in Agda and as a
description. You can also borrow a type to encode from
<a href="http://www.cse.chalmers.se/~peterd/papers/Indexed_IR.pdf">Dybjer &amp; Setzer&rsquo;s paper on the topic</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modeling Elimination of Described Types]]></title>
    <link href="http://spire-lang.org/blog/2014/01/15/modeling-elimination-of-described-types/"/>
    <updated>2014-01-15T09:50:12-08:00</updated>
    <id>http://spire-lang.org/blog/2014/01/15/modeling-elimination-of-described-types</id>
    <content type="html"><![CDATA[<p>Before jumping straight into implementing datatypes via descriptions,
it is convient to be able model some of them in Agda (as done in
<a href="http://gallium.inria.fr/~pdagand/papers/levitation.pdf">The Gentle Art of Levitation</a>
by Chapman et. al.
and subsequent papers). Everything in the surface language, such as
datatype declarations and pattern matching, is elaborated to terms of
the core type theory. It is desirable to have the ingredients of the
core type theory be as similar to their higher level counterparts as
possible, otherwise work on the canonical terms (such as embedding
back upwards, generic programming on core terms, and compilation of
core terms) becomes complex.</p>

<!-- more -->


<p>My desired features for a bare bones version 1 of Spire include:</p>

<ul>
<li>implicit arguments</li>
<li>elaboration of datatype declarations to descriptions</li>
<li>elaboration of pattern matching syntax to eliminators</li>
<li>later superceded by elaboration to the &ldquo;by&rdquo; gadget from
<a href="http://strictlypositive.org/view.ps.gz">The view from the left</a>  by McBride</li>
<li>sugar for performing generic programming over descriptions</li>
<li>formal metatheory for the canonical type theory</li>
<li>universe levels</li>
</ul>


<p>Rather than implementing this all at once, certain features are
gradually being added. However, it is still a good idea to have future
features in mind when implementing something, and the Agda model helps
with that. The process goes like this:</p>

<ol>
<li>Write down the high-level notation that Agda supports natively (or
in a comment, for features that Agda does not support)</li>
<li>Manually perform the elaboration procedures on paper</li>
<li>Typecheck and study the resulting core type theory terms</li>
</ol>


<p>Elaboration of a high level term can involve many steps that
are individually easy to follow, but produce a complex final term, and
it is worth considering alternative core type theory constructs to
produce simpler final terms. These sorts of before-and-after pictures,
and most concepts in this post, can be found in
<a href="http://gallium.inria.fr/~pdagand/stuffs/thesis-2011-phd/thesis.pdf">Pierre Dagand&rsquo;s thesis</a>.</p>

<h2>Note</h2>

<p>All of the code from this post can be
<a href="https://github.com/spire/spire/tree/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples">found in Spire</a>.
Additionally, each code snippet contains a link to the specific file
in the <strong>top right corner</strong>.</p>

<h2>Pattern Matching</h2>

<p>When first implementing the <code>Desc</code>ription technology, it will be
convenient to have a sufficiently complex example to typecheck. The
following standard sequence of types and functions suits this goal.</p>

<figure class='code'><figcaption><span>Functions using Pattern Matching</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/Standard.agda#L34-L52'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="err">ℕ</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">zero</span> <span class="kt">:</span> <span class="err">ℕ</span>
</span><span class='line'>  <span class="n">suc</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">nil</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">zero</span>
</span><span class='line'>  <span class="n">cons</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">add</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class='line'><span class="nf">add</span> <span class="n">zero</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span>
</span><span class='line'><span class="nf">add</span> <span class="p">(</span><span class="n">suc</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">suc</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mult</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class='line'><span class="nf">mult</span> <span class="n">zero</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">zero</span>
</span><span class='line'><span class="nf">mult</span> <span class="p">(</span><span class="n">suc</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">add</span> <span class="n">n</span> <span class="p">(</span><span class="n">mult</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">append</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="o">.</span><span class="n">zero</span> <span class="n">nil</span> <span class="n">n</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="o">.</span><span class="p">(</span><span class="n">suc</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">cons</span> <span class="n">m</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="n">n</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">cons</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="n">n</span> <span class="n">ys</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">concat</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">xss</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="o">.</span><span class="n">zero</span> <span class="n">nil</span> <span class="ow">=</span> <span class="n">nil</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="o">.</span><span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">cons</span> <span class="n">n</span> <span class="n">xs</span> <span class="n">xss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">n</span> <span class="n">xss</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This sequence of functions has the nice property that each function
builds upon the previous ones (either in its type, value, or both),
ending in the definition of <code>concat</code>. Furthemore, concat has
a moderatley complicated dependent type, but only eliminates type
families applied to a sequence of variables. Eliminating type families
applied to expressions built from constructors requires more clever motive synthesis
(via <a href="http://strictlypositive.org/goguen.pdf">Eliminating Dependent Pattern Matching</a>
by Goguen et. al.) that I would like to ignore for this first pass.</p>

<h2>Eliminators</h2>

<p>Translating these basic functions into eliminators is straightforward.
Because we only eliminate type families applied to a sequence
of variables, the branch functions supplied to the eliminator look like
pattern matching, and the whole definition is rather compact.</p>

<figure class='code'><figcaption><span>Functions using Eliminators</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/Standard.agda#L54-L76'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class='line'><span class="nf">add</span> <span class="ow">=</span> <span class="n">elim</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">suc</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mult</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span>
</span><span class='line'><span class="nf">mult</span> <span class="ow">=</span> <span class="n">elim</span><span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="n">zero</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">add</span> <span class="n">n</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nf">append</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="ow">=</span> <span class="n">elimVec</span> <span class="kt">A</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">xs</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">ys</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">cons</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nf">concat</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="p">(</span><span class="n">xss</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">elimVec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xss</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span>
</span><span class='line'>  <span class="n">nil</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xs</span> <span class="n">xss</span> <span class="n">ih</span> <span class="err">→</span> <span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Computational Descriptions</h2>

<p>Now we will consider <code>Desc</code>riptions as they appear in
<a href="http://gallium.inria.fr/~pdagand/stuffs/thesis-2011-phd/thesis.pdf">Dagand&rsquo;s thesis</a>,
which are the core type theory analogue to surface language datatype
definitions.</p>

<figure class='code'><figcaption><span>Computational Description Datatypes</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/ComputationalDesc.agda#L19-L20'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Desc</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span><span class="err">₁</span> <span class="kr">where</span>
</span><span class='line'>  <span class="p">`</span><span class="err">⊤</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>  <span class="p">`</span><span class="kt">X</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>  <span class="p">`</span><span class="err">Σ</span> <span class="p">`</span><span class="err">Π</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>
</span><span class='line'><span class="kt">El</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">`</span><span class="err">⊤</span> <span class="kt">X</span> <span class="ow">=</span> <span class="err">⊤</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="kt">X</span> <span class="n">i</span><span class="p">)</span> <span class="kt">X</span> <span class="ow">=</span> <span class="kt">X</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="err">Σ</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="ow">=</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="p">(</span><span class="err">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">El</span> <span class="kt">I</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">X</span><span class="p">)</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="err">Π</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">El</span> <span class="kt">I</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">X</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="err">μ</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">R</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">con</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">I</span> <span class="p">(</span><span class="kt">R</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span><span class="p">)</span> <span class="err">→</span> <span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span> <span class="n">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>A well known isomorphism exists between sums and dependent products
whose domain is some finite collection. To encode a type such as <code>ℕ</code>,
we can use a <code>Σ</code> whose domain is an index into an enumeration of the
contructor names <code>zero</code> and <code>suc</code>.</p>

<figure class='code'><figcaption><span>Computational ℕ Declaration</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/ComputationalDesc.agda#L57-L67'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span> <span class="p">`</span><span class="n">zero</span> <span class="p">`</span><span class="n">suc</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="kt">T</span>
</span><span class='line'>
</span><span class='line'><span class="err">ℕ</span><span class="kt">D</span> <span class="kt">:</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="err">⊤</span>
</span><span class='line'><span class="err">ℕ</span><span class="kt">D</span> <span class="n">tt</span> <span class="ow">=</span> <span class="p">`</span><span class="err">Σ</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="err">λ</span>
</span><span class='line'>  <span class="p">{</span> <span class="p">`</span><span class="n">zero</span> <span class="err">→</span> <span class="p">`</span><span class="err">⊤</span>
</span><span class='line'>  <span class="p">;</span> <span class="p">`</span><span class="n">suc</span> <span class="err">→</span> <span class="p">`</span><span class="kt">X</span> <span class="n">tt</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">ℕ</span> <span class="kt">:</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="err">ℕ</span> <span class="ow">=</span> <span class="err">μ</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&rsquo;ve been reading carefully, you noticed that <code>μ</code> did not take a
<code>Desc</code>ription as an argument, but a function from the index to a
description. Certain type families can be defined computationally (as
functions from their index), as in
<a href="http://eb.host.cs.st-andrews.ac.uk/writings/types2003.pdf">Inductive Families Need Not Store Their Indices</a>
by Brady et. al. Eliminating functions defined in this style leads to
particularly nice reduction behaviour, buying you free equations
thanks to definitional equality. <code>ℕ</code> was not indexed, but below is an
example of defining <code>Vec</code> as a computational description.</p>

<figure class='code'><figcaption><span>Computational Vec Declaration</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/ComputationalDesc.agda#L77-L82'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">VecT</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span> <span class="p">`</span><span class="n">nil</span> <span class="p">`</span><span class="n">cons</span> <span class="kt">:</span> <span class="kt">VecT</span>
</span><span class='line'>
</span><span class='line'><span class="kt">VecD</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'><span class="kt">VecD</span> <span class="kt">A</span> <span class="n">zero</span> <span class="ow">=</span> <span class="p">`</span><span class="err">⊤</span>
</span><span class='line'><span class="kt">VecD</span> <span class="kt">A</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">`</span><span class="err">Σ</span> <span class="kt">A</span> <span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="p">`</span><span class="kt">X</span> <span class="n">n</span>
</span><span class='line'>
</span><span class='line'><span class="kt">Vec</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="ow">=</span> <span class="err">μ</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rather than using a standard eliminator on datatypes defined using
descriptions, the special <code>ind</code> elimination rule is used. An
eliminator has separate &ldquo;branches&rdquo; for each constructor of a datatype,
along with proofs of the motive being satisfied at recursive positions
in the constructor. Intead, <code>ind</code> has a single branch (called <code>pcon</code>
below) that bundles up all branches of a typical eliminator, along
with an <code>All</code> argument for all recursive motive proofs.</p>

<figure class='code'><figcaption><span>ind Elimination Rule Type</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/ComputationalDesc.agda#L30-L37'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">ind</span> <span class="kt">:</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">R</span> <span class="kt">:</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span> <span class="n">i</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">pcon</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">I</span> <span class="p">(</span><span class="kt">R</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span><span class="p">))</span> <span class="err">→</span> <span class="kt">All</span> <span class="kt">I</span> <span class="p">(</span><span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span><span class="p">)</span> <span class="p">(</span><span class="kt">R</span> <span class="n">i</span><span class="p">)</span> <span class="n">xs</span> <span class="kt">P</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">i</span> <span class="p">(</span><span class="n">con</span> <span class="n">xs</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="err">μ</span> <span class="kt">I</span> <span class="kt">R</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="err">→</span> <span class="kt">P</span> <span class="n">i</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using this eliminator we can define our running example of function
definitions. Here we use <code>ind</code> rather than pattern matching. The
anonymous function argument represents sugared &ldquo;{}&rdquo; syntax from
Dagand thesis <code>Example 3.19</code>. Additionally, the arguments bound in each
constructor pattern match clause are desugared into projections on the
right hand side. We will see what the final desugared terms look like
later in this post.</p>

<figure class='code'><figcaption><span>Computational Desc Functions</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/ComputationalDesc.agda#L92-L124'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">add</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span>
</span><span class='line'>    <span class="p">;</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">suc</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mult</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">mult</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">zero</span>
</span><span class='line'>    <span class="p">;</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">add</span> <span class="n">n</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">append</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">xs</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">zero</span> <span class="n">tt</span> <span class="n">tt</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">ys</span>
</span><span class='line'>    <span class="p">;</span> <span class="p">(</span><span class="n">suc</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">cons</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">concat</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xss</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xss</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">zero</span> <span class="n">tt</span> <span class="n">tt</span> <span class="err">→</span> <span class="n">nil</span> <span class="kt">A</span>
</span><span class='line'>    <span class="p">;</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="p">,</span> <span class="n">xss</span><span class="p">)</span> <span class="n">ih</span> <span class="err">→</span> <span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Definitions using computational descriptions (like the ones above) are
nice because you can pattern match on the index (e.g. <code>ℕ</code>) and the
description for the type family (e.g. <code>Vec</code>) definitionally unfolds.
However, things get a bit clunkier once we wish to support named
constructor arguments. Notice that we defined <code>ℕ</code> with an enumeration
for the constructor arguments, but we did not do the same for <code>Vec</code>.
<code>Example 7.46</code> in Dagand shows how to elaborate <code>Vec</code> into a description
that has named constructor arguments. This involves first wrapping the
description in an <code>elim</code> constructor to identify <code>Vec</code> as a type defined
by computation over its index. Then, the <code>zero</code> and <code>suc</code> branches
return <code>zero</code> and <code>suc</code> constructor tags respectively. In this case,
the constructors index into singleton enumerations, i.e. <code>elim</code> into
<code>[elim]</code>, <code>zero</code> into <code>[zero]</code>, and <code>suc</code> into <code>[suc]</code>. If we were
defining a type that had multiple constructors with the same index for
a particular index branch then the enumeration would not
be a singleton, but it would still only be sub-enumeration of the
total enumeration of constructors that we have in mind for the type.</p>

<p>In contrast,
the <code>ℕ</code> description tag constructors both belong to a more natural
enumeration, i.e. <code>zero</code> and <code>suc</code> index into <code>[zero, suc]</code>. Hence,
although functions like <code>append</code> and <code>concat</code> defined above over
computational description <code>Vec</code> look nice, once you add these
singleton tags and desugar everything, you get lots of eliminations
over singleton enumerations that are IMO no longer as elegant.
Additionally, type families defined by computation over the index are
only a subclass of all possible type families. The remaining types
(and actually, all type families) can be alternatively defined by
constraining the index with a propositional equality proof. See Dagand
<code>Example 7.45</code> for how to define <code>Vec</code> this way. This type of definition
keeps the more natural enumeration of constructor tags. I will call
types defined this way &ldquo;propositional descriptions&rdquo;.</p>

<h2>Propositional Descriptions</h2>

<p>Although computational descriptions give you an additional way to
define types, in practice once you add named constructors and perform
elaboration of patterns to eliminators, I don&rsquo;t feel like they buy you
enough for the additional complexity. I am content with supporting
Agda-style propositionally defined datatypes exclusively. Given this
decision, we can change the grammar of descriptions to more
closely resemble the surface language Agda-style datatype
declarations. I saw something like this alternative <code>Desc</code> definition
from the code accompanying a
<a href="http://perso.ens-lyon.fr/guillaume.allais/?en/main/blog/read/syntax-binding-run-omega">blog post</a>
by Guillaume Allais.</p>

<figure class='code'><figcaption><span>Propositional Description Datatypes</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L38-L54'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Desc</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span><span class="err">₁</span> <span class="kr">where</span>
</span><span class='line'>  <span class="p">`</span><span class="kt">End</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>  <span class="p">`</span><span class="kt">Rec</span> <span class="kt">:</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>  <span class="p">`</span><span class="kt">Arg</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>  <span class="p">`</span><span class="kt">RecFun</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'>
</span><span class='line'><span class="kt">ISet</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="err">→</span> <span class="kt">Set</span><span class="err">₁</span>
</span><span class='line'><span class="kt">ISet</span> <span class="kt">I</span> <span class="ow">=</span> <span class="kt">I</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'>
</span><span class='line'><span class="kt">El</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="kt">X</span> <span class="kt">:</span> <span class="kt">ISet</span> <span class="kt">I</span><span class="p">)</span> <span class="err">→</span> <span class="kt">ISet</span> <span class="kt">I</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="kt">End</span> <span class="n">j</span><span class="p">)</span> <span class="kt">X</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">j</span> <span class="err">≡</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="kt">Rec</span> <span class="n">j</span> <span class="kt">D</span><span class="p">)</span> <span class="kt">X</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">X</span> <span class="n">j</span> <span class="err">×</span> <span class="kt">El</span> <span class="kt">I</span> <span class="kt">D</span> <span class="kt">X</span> <span class="n">i</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="kt">B</span><span class="p">)</span> <span class="kt">X</span> <span class="n">i</span> <span class="ow">=</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="p">(</span><span class="err">λ</span> <span class="n">a</span> <span class="err">→</span> <span class="kt">El</span> <span class="kt">I</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">)</span> <span class="kt">X</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="kt">El</span> <span class="kt">I</span> <span class="p">(`</span><span class="kt">RecFun</span> <span class="kt">A</span> <span class="kt">B</span> <span class="kt">D</span><span class="p">)</span> <span class="kt">X</span> <span class="n">i</span> <span class="ow">=</span> <span class="p">((</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">X</span> <span class="p">(</span><span class="kt">B</span> <span class="n">a</span><span class="p">))</span> <span class="err">×</span> <span class="kt">El</span> <span class="kt">I</span> <span class="kt">D</span> <span class="kt">X</span> <span class="n">i</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="err">μ</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="kt">I</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">con</span> <span class="kt">:</span> <span class="kt">El</span> <span class="kt">I</span> <span class="kt">D</span> <span class="p">(</span><span class="err">μ</span> <span class="kt">I</span> <span class="kt">D</span><span class="p">)</span> <span class="n">i</span> <span class="err">→</span> <span class="err">μ</span> <span class="kt">I</span> <span class="kt">D</span> <span class="n">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>This description grammar enforces descriptions to look like what we
are used to seeing in datatype declarations. For example,
<code>Rec/Arg/RecFun</code>, corresponding to the previous <code>X/Σ/Π</code> constructors,
take an extra
description argument at the end. Then <code>End</code>, formerly <code>⊤</code>, ends the
&ldquo;constructor&rdquo; with an index value. The interpretation function uses
this index value to ask for a propositionally equality proof, making
sure that the index of the constructor you produce matches the index
of the type you specified. This can be achieved in the previous <code>Desc</code>
grammar by ending a description with <code>Σ (x ≡ y) λ _ → ⊤</code>, but here
that pattern is internalized. One pleasant consequence can be seen by
looking at the <code>μ</code> datatype. It no longer requires a function from the
index to a description, and now merely requires a description. Because
we no longer support computational described datatypes (instead
describing them all propositionally), our descriptions can be
first-order rather than higher-order. The more first-order your
descriptions are, the more
<a href="https://github.com/larrytheliquid/leveling-up">fully generic programming</a>
you can do over them.</p>

<p>The <code>ℕ</code> datatype is declared pretty much the same as before. However,
<code>Vec</code> is now given with its constructor names, and the index of a
particular constructor is given at the end of the sequence of
constructor arguments. Compare this to the Agda data declaration at
the top of the post and notice the similar structure.</p>

<figure class='code'><figcaption><span>Propositional ℕ & Vec Declarations</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L97-L122'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'>  <span class="kr">data</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span> <span class="p">`</span><span class="n">zero</span> <span class="p">`</span><span class="n">suc</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="kt">T</span>
</span><span class='line'>  <span class="kr">data</span> <span class="kt">VecT</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span> <span class="p">`</span><span class="n">nil</span> <span class="p">`</span><span class="n">cons</span> <span class="kt">:</span> <span class="kt">VecT</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">ℕ</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="err">⊤</span>
</span><span class='line'>  <span class="err">ℕ</span><span class="kt">D</span> <span class="ow">=</span> <span class="p">`</span><span class="kt">Arg</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="p">`</span><span class="n">zero</span> <span class="err">→</span> <span class="p">`</span><span class="kt">End</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">;</span> <span class="p">`</span><span class="n">suc</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Rec</span> <span class="n">tt</span> <span class="p">(`</span><span class="kt">End</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">ℕ</span> <span class="kt">:</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'>  <span class="err">ℕ</span> <span class="ow">=</span> <span class="err">μ</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">VecD</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="kt">VecD</span> <span class="kt">A</span> <span class="ow">=</span> <span class="p">`</span><span class="kt">Arg</span> <span class="kt">VecT</span> <span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="p">`</span><span class="n">nil</span>  <span class="err">→</span> <span class="p">`</span><span class="kt">End</span> <span class="n">zero</span>
</span><span class='line'>    <span class="p">;</span> <span class="p">`</span><span class="n">cons</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Arg</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Rec</span> <span class="n">n</span> <span class="p">(`</span><span class="kt">End</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">Vec</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'>  <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="ow">=</span> <span class="err">μ</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our function definitions for <code>add</code> and <code>mult</code> are pretty much
unchanged, but <code>append</code> and <code>concat</code> have one significant difference.
Both <code>Vec</code> constructors do a dependent pattern match on a
propositional equality proof. However, this is once again a rather
simple dependent match that can just be elaborated to uses of
substitution. Specifically, this elaboration is the <code>solution</code> step of
<code>Lemma 16</code> in
<a href="http://strictlypositive.org/goguen.pdf">Eliminating Dependent Pattern Matching</a>.</p>

<figure class='code'><figcaption><span>Propositional Desc Functions</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L132-L164'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">add</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span>
</span><span class='line'>    <span class="p">;</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">m</span> <span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="n">ih</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="n">n</span> <span class="err">→</span> <span class="n">suc</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mult</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">mult</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">zero</span>
</span><span class='line'>    <span class="p">;</span> <span class="n">tt</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">m</span> <span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="n">ih</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="n">n</span> <span class="err">→</span> <span class="n">add</span> <span class="n">n</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">append</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">xs</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="o">.</span><span class="p">(</span><span class="n">con</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">refl</span><span class="p">))</span> <span class="p">(`</span><span class="n">nil</span> <span class="p">,</span> <span class="n">refl</span><span class="p">)</span> <span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">ys</span>
</span><span class='line'>    <span class="p">;</span> <span class="o">.</span><span class="p">(</span><span class="n">con</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">m</span> <span class="p">,</span> <span class="n">refl</span><span class="p">))</span> <span class="p">(`</span><span class="n">cons</span> <span class="p">,</span> <span class="n">m</span> <span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">xs</span> <span class="p">,</span> <span class="n">refl</span><span class="p">)</span> <span class="p">(</span><span class="n">ih</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">cons</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">concat</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xss</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xss</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span>
</span><span class='line'>    <span class="p">{</span> <span class="o">.</span><span class="p">(</span><span class="n">con</span> <span class="p">(`</span><span class="n">zero</span> <span class="p">,</span> <span class="n">refl</span><span class="p">))</span> <span class="p">(`</span><span class="n">nil</span> <span class="p">,</span> <span class="n">refl</span><span class="p">)</span> <span class="n">tt</span> <span class="err">→</span> <span class="n">nil</span> <span class="kt">A</span>
</span><span class='line'>    <span class="p">;</span> <span class="o">.</span><span class="p">(</span><span class="n">con</span> <span class="p">(`</span><span class="n">suc</span> <span class="p">,</span> <span class="n">n</span> <span class="p">,</span> <span class="n">refl</span><span class="p">))</span> <span class="p">(`</span><span class="n">cons</span> <span class="p">,</span> <span class="n">n</span> <span class="p">,</span> <span class="n">xs</span> <span class="p">,</span> <span class="n">xss</span> <span class="p">,</span> <span class="n">refl</span><span class="p">)</span> <span class="p">(</span><span class="n">ih</span> <span class="p">,</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Desugared Propositional Descriptions</h2>

<p>I will now show the desugared final forms of the propositional
description code given so far. It is very important to study these
terms carefully, as they are the terms of our canonical type theory
and will appear as types everywhere throughout our language (because types
are fully evaluated terms).</p>

<p>The first bit of sugar we will get rid of has to do with the pattern
matching we have been performing on finite enumerations of tags
(representing constructor names). The enumeration <code>Enum</code> will be a
list of strings. <code>Tag</code> is an index into <code>Enum</code> (like <code>Fin</code> into <code>ℕ</code>).
<code>Cases</code> is a finite product of values in a type family indexed by each
<code>Tag</code> (like <code>Vec</code> with type family values indexed by <code>ℕ</code>). Finally,
<code>case</code> eliminates a tag by returning the value in <code>Cases</code> at that
position/name. I&rsquo;ve renamed these contstructs, and their original
names in Dagand are <code>EnumU</code>, <code>EnumT</code>, <code>π</code>, and <code>switch</code> and can be
found in <code>Definition 2.49</code> and <code>Definition 2.52</code>.</p>

<figure class='code'><figcaption><span>Enum & Tag</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L18-L34'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kt">Label</span> <span class="kt">:</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">Label</span> <span class="ow">=</span> <span class="kt">String</span>
</span><span class='line'>
</span><span class='line'><span class="kt">Enum</span> <span class="kt">:</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">Enum</span> <span class="ow">=</span> <span class="kt">List</span> <span class="kt">Label</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">Tag</span> <span class="kt">:</span> <span class="kt">Enum</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class='line'>  <span class="n">here</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">l</span> <span class="kt">E</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Tag</span> <span class="p">(</span><span class="n">l</span> <span class="err">∷</span> <span class="kt">E</span><span class="p">)</span>
</span><span class='line'>  <span class="n">there</span> <span class="kt">:</span> <span class="err">∀</span><span class="p">{</span><span class="n">l</span> <span class="kt">E</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Tag</span> <span class="kt">E</span> <span class="err">→</span> <span class="kt">Tag</span> <span class="p">(</span><span class="n">l</span> <span class="err">∷</span> <span class="kt">E</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kt">Cases</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">E</span> <span class="kt">:</span> <span class="kt">Enum</span><span class="p">)</span> <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Tag</span> <span class="kt">E</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">Cases</span> <span class="kt">[]</span> <span class="kt">P</span> <span class="ow">=</span> <span class="err">⊤</span>
</span><span class='line'><span class="kt">Cases</span> <span class="p">(</span><span class="n">l</span> <span class="err">∷</span> <span class="kt">E</span><span class="p">)</span> <span class="kt">P</span> <span class="ow">=</span> <span class="kt">P</span> <span class="n">here</span> <span class="err">×</span> <span class="kt">Cases</span> <span class="kt">E</span> <span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">there</span> <span class="n">t</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">case</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">E</span> <span class="kt">:</span> <span class="kt">Enum</span><span class="p">)</span> <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Tag</span> <span class="kt">E</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">cs</span> <span class="kt">:</span> <span class="kt">Cases</span> <span class="kt">E</span> <span class="kt">P</span><span class="p">)</span> <span class="p">(</span><span class="n">t</span> <span class="kt">:</span> <span class="kt">Tag</span> <span class="kt">E</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">t</span>
</span><span class='line'><span class="kr">case</span> <span class="p">(</span><span class="n">l</span> <span class="err">∷</span> <span class="kt">E</span><span class="p">)</span> <span class="kt">P</span> <span class="p">(</span><span class="n">c</span> <span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="n">here</span> <span class="ow">=</span> <span class="n">c</span>
</span><span class='line'><span class="kr">case</span> <span class="p">(</span><span class="n">l</span> <span class="err">∷</span> <span class="kt">E</span><span class="p">)</span> <span class="kt">P</span> <span class="p">(</span><span class="n">c</span> <span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="p">(</span><span class="n">there</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="kt">E</span> <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">there</span> <span class="n">t</span><span class="p">))</span> <span class="n">cs</span> <span class="n">t</span>
</span><span class='line'>
</span><span class='line'><span class="nf">caseD</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">E</span> <span class="kt">:</span> <span class="kt">Enum</span><span class="p">)</span> <span class="p">(</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">cs</span> <span class="kt">:</span> <span class="kt">Cases</span> <span class="kt">E</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">))</span> <span class="p">(</span><span class="n">t</span> <span class="kt">:</span> <span class="kt">Tag</span> <span class="kt">E</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span>
</span><span class='line'><span class="nf">caseD</span> <span class="kt">E</span> <span class="kt">I</span> <span class="n">cs</span> <span class="n">t</span> <span class="ow">=</span> <span class="kr">case</span> <span class="kt">E</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="kt">I</span><span class="p">)</span> <span class="n">cs</span> <span class="n">t</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the sugared version of descriptions for datatypes we match on a tag
and return a description for it. In the desugared version, we instead
eliminate a tag with the special <code>case</code> elimination rule.</p>

<figure class='code'><figcaption><span>Desugared ℕ & Vec Declarations</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L170-L206'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="err">ℕ</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">Enum</span>
</span><span class='line'><span class="err">ℕ</span><span class="kt">T</span> <span class="ow">=</span> <span class="s">&quot;zero&quot;</span> <span class="err">∷</span> <span class="s">&quot;suc&quot;</span> <span class="err">∷</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="kt">VecT</span> <span class="kt">:</span> <span class="kt">Enum</span>
</span><span class='line'><span class="kt">VecT</span> <span class="ow">=</span> <span class="s">&quot;nil&quot;</span> <span class="err">∷</span> <span class="s">&quot;cons&quot;</span> <span class="err">∷</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="err">ℕ</span><span class="kt">C</span> <span class="kt">:</span> <span class="kt">Tag</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="err">⊤</span>
</span><span class='line'><span class="err">ℕ</span><span class="kt">C</span> <span class="ow">=</span> <span class="n">caseD</span> <span class="err">ℕ</span><span class="kt">T</span> <span class="err">⊤</span>
</span><span class='line'>  <span class="p">(</span> <span class="p">`</span><span class="kt">End</span> <span class="n">tt</span>
</span><span class='line'>  <span class="p">,</span> <span class="p">`</span><span class="kt">Rec</span> <span class="n">tt</span> <span class="p">(`</span><span class="kt">End</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="err">ℕ</span><span class="kt">D</span> <span class="kt">:</span> <span class="kt">Desc</span> <span class="err">⊤</span>
</span><span class='line'><span class="err">ℕ</span><span class="kt">D</span> <span class="ow">=</span> <span class="p">`</span><span class="kt">Arg</span> <span class="p">(</span><span class="kt">Tag</span> <span class="err">ℕ</span><span class="kt">T</span><span class="p">)</span> <span class="err">ℕ</span><span class="kt">C</span>
</span><span class='line'>
</span><span class='line'><span class="err">ℕ</span> <span class="kt">:</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="err">ℕ</span> <span class="ow">=</span> <span class="err">μ</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span>
</span><span class='line'>
</span><span class='line'><span class="kt">VecC</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Tag</span> <span class="kt">VecT</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'><span class="kt">VecC</span> <span class="kt">A</span> <span class="ow">=</span> <span class="n">caseD</span> <span class="kt">VecT</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span> <span class="p">`</span><span class="kt">End</span> <span class="n">zero</span>
</span><span class='line'>  <span class="p">,</span> <span class="p">`</span><span class="kt">Arg</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Arg</span> <span class="kt">A</span> <span class="err">λ</span> <span class="kr">_</span> <span class="err">→</span> <span class="p">`</span><span class="kt">Rec</span> <span class="n">n</span> <span class="p">(`</span><span class="kt">End</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)))</span>
</span><span class='line'>  <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kt">VecD</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Desc</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'><span class="kt">VecD</span> <span class="kt">A</span> <span class="ow">=</span> <span class="p">`</span><span class="kt">Arg</span> <span class="p">(</span><span class="kt">Tag</span> <span class="kt">VecT</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecC</span> <span class="kt">A</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kt">Vec</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span>
</span><span class='line'><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="ow">=</span> <span class="err">μ</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now brace yourself for the rather wordy desugared version of our
series of function definitions. The general pattern for these is that
we first use <code>ind</code> on the datatype being eliminated (like before),
then we use <code>case</code> to give a branch for each constructor. Because
<code>case</code> eliminates a tag out of the domain of a dependent pair,
we must use the
<a href="http://adam.chlipala.net/cpdt/html/MoreDep.html">convoy pattern</a>
to have the codomain properly unfold. As mentioned before, &ldquo;matching&rdquo; on
our propositional equality proof is done by applying <code>subst</code>. Finally,
each argument to a constructor is referenced by its projection out of
the tuple of arguments you actually get out of the constructor.</p>

<figure class='code'><figcaption><span>Desugared Desc Functions</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L218-L292'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">add</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="err">ℕ</span><span class="kt">T</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="err">⊤</span> <span class="p">(</span><span class="err">ℕ</span><span class="kt">C</span> <span class="n">t</span><span class="p">)</span> <span class="err">ℕ</span> <span class="n">u</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span><span class="p">)</span> <span class="n">u</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">suc</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">mult</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span>
</span><span class='line'><span class="nf">mult</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="kr">_</span> <span class="kr">_</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="err">ℕ</span><span class="kt">T</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="err">⊤</span> <span class="p">(</span><span class="err">ℕ</span><span class="kt">C</span> <span class="n">t</span><span class="p">)</span> <span class="err">ℕ</span> <span class="n">u</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">n</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span><span class="p">)</span> <span class="n">u</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span> <span class="err">→</span> <span class="err">ℕ</span> <span class="n">u</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="n">n</span> <span class="err">→</span> <span class="n">zero</span><span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="n">n</span> <span class="err">→</span> <span class="n">add</span> <span class="n">n</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">append</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="nf">append</span> <span class="kt">A</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">xs</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="kt">VecT</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecC</span> <span class="kt">A</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span><span class="p">)</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="n">xs</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span> <span class="n">m</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span> <span class="n">subst</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span> <span class="n">q</span> <span class="n">ys</span><span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="n">n</span> <span class="n">ys</span> <span class="err">→</span>
</span><span class='line'>        <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">m&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span>
</span><span class='line'>            <span class="n">x</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">m&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'>            <span class="n">q</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">m&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
</span><span class='line'>            <span class="n">ih</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span>
</span><span class='line'>        <span class="kr">in</span>
</span><span class='line'>        <span class="n">subst</span> <span class="p">(</span><span class="err">λ</span> <span class="n">m</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">n</span><span class="p">))</span> <span class="n">q</span> <span class="p">(</span><span class="n">cons</span> <span class="kt">A</span> <span class="p">(</span><span class="n">add</span> <span class="n">m&#39;</span> <span class="n">n</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">ih</span> <span class="n">n</span> <span class="n">ys</span><span class="p">))</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">concat</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">xss</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="nf">concat</span> <span class="kt">A</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xss</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="kt">VecT</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecC</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="p">(</span><span class="kt">Vec</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span> <span class="n">m</span><span class="p">))</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xss</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span> <span class="n">n</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="err">→</span> <span class="n">subst</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span> <span class="n">q</span> <span class="p">(</span><span class="n">nil</span> <span class="kt">A</span><span class="p">))</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xss</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="err">→</span>
</span><span class='line'>        <span class="kr">let</span> <span class="n">n&#39;</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xss</span><span class="p">,</span><span class="n">q</span>
</span><span class='line'>            <span class="n">xs</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xss</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'>            <span class="n">q</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">xss</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
</span><span class='line'>            <span class="n">ih</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span>
</span><span class='line'>        <span class="kr">in</span>
</span><span class='line'>        <span class="n">subst</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n</span> <span class="n">m</span><span class="p">))</span> <span class="n">q</span> <span class="p">(</span><span class="n">append</span> <span class="kt">A</span> <span class="n">m</span> <span class="n">xs</span> <span class="p">(</span><span class="n">mult</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="p">)</span> <span class="n">ih</span><span class="p">)</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Alternatively, rather than defining these functions with <code>ind</code>,
<code>case</code>, and <code>subst</code> directly, we can define the eliminators using
<code>ind</code> and reuse our former definitions that use eliminators.</p>

<figure class='code'><figcaption><span>Desugared Eliminators</span><a href='https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/PropositionalDesc.agda#L298-L358'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">elim</span><span class="err">ℕ</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">pzero</span> <span class="kt">:</span> <span class="kt">P</span> <span class="n">zero</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">psuc</span> <span class="kt">:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">m</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">suc</span> <span class="n">m</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span>
</span><span class='line'><span class="nf">elim</span><span class="err">ℕ</span> <span class="kt">P</span> <span class="n">pzero</span> <span class="n">psuc</span> <span class="ow">=</span> <span class="n">ind</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="err">ℕ</span><span class="kt">T</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="err">⊤</span> <span class="p">(</span><span class="err">ℕ</span><span class="kt">C</span> <span class="n">t</span><span class="p">)</span> <span class="err">ℕ</span> <span class="n">u</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="err">⊤</span> <span class="err">ℕ</span><span class="kt">D</span> <span class="err">ℕ</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span><span class="p">)</span> <span class="n">u</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="err">→</span>
</span><span class='line'>        <span class="n">elimEq</span> <span class="err">⊤</span> <span class="n">tt</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">q</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">here</span> <span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
</span><span class='line'>          <span class="n">pzero</span>
</span><span class='line'>          <span class="n">u</span> <span class="n">q</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="err">→</span>
</span><span class='line'>        <span class="n">elimEq</span> <span class="err">⊤</span> <span class="n">tt</span> <span class="p">(</span><span class="err">λ</span> <span class="n">u</span> <span class="n">q</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">there</span> <span class="n">here</span> <span class="p">,</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">n</span><span class="p">,</span><span class="n">q</span> <span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
</span><span class='line'>          <span class="p">(</span><span class="n">psuc</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">n</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span><span class="p">))</span>
</span><span class='line'>          <span class="n">u</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="n">tt</span>
</span><span class='line'>
</span><span class='line'><span class="nf">elimVec</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">P</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">pnil</span> <span class="kt">:</span> <span class="kt">P</span> <span class="n">zero</span> <span class="p">(</span><span class="n">nil</span> <span class="kt">A</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="n">pcons</span> <span class="kt">:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="n">xs</span> <span class="err">→</span> <span class="kt">P</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">cons</span> <span class="kt">A</span> <span class="n">n</span> <span class="n">a</span> <span class="n">xs</span><span class="p">))</span>
</span><span class='line'>  <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">xs</span> <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">A</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="n">xs</span>
</span><span class='line'><span class="nf">elimVec</span> <span class="kt">A</span> <span class="kt">P</span> <span class="n">pnil</span> <span class="n">pcons</span> <span class="ow">=</span> <span class="n">ind</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xs</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="n">xs</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="err">→</span> <span class="kr">case</span> <span class="kt">VecT</span>
</span><span class='line'>    <span class="p">(</span><span class="err">λ</span> <span class="n">t</span> <span class="err">→</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:</span> <span class="kt">El</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecC</span> <span class="kt">A</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>           <span class="p">(</span><span class="n">ih</span> <span class="kt">:</span> <span class="kt">All</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="kt">VecD</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="kt">Vec</span> <span class="kt">A</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">xs</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="n">xs</span><span class="p">)</span> <span class="n">n</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>           <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">t</span> <span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span> <span class="p">(</span><span class="err">λ</span> <span class="n">q</span> <span class="n">ih</span> <span class="err">→</span>
</span><span class='line'>        <span class="n">elimEq</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="n">zero</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">q</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">here</span> <span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
</span><span class='line'>          <span class="n">pnil</span>
</span><span class='line'>          <span class="n">n</span> <span class="n">q</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span> <span class="err">→</span>
</span><span class='line'>        <span class="kr">let</span> <span class="n">n&#39;</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span>
</span><span class='line'>            <span class="n">x</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'>            <span class="n">xs</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
</span><span class='line'>            <span class="n">q</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
</span><span class='line'>            <span class="n">ih</span> <span class="ow">=</span> <span class="n">proj</span><span class="err">₁</span> <span class="n">ih</span><span class="p">,</span><span class="n">tt</span>
</span><span class='line'>        <span class="kr">in</span>
</span><span class='line'>        <span class="n">elimEq</span> <span class="p">(</span><span class="err">ℕ</span> <span class="n">tt</span><span class="p">)</span> <span class="p">(</span><span class="n">suc</span> <span class="n">n&#39;</span><span class="p">)</span> <span class="p">(</span><span class="err">λ</span> <span class="n">n</span> <span class="n">q</span> <span class="err">→</span> <span class="kt">P</span> <span class="n">n</span> <span class="p">(</span><span class="n">con</span> <span class="p">(</span><span class="n">there</span> <span class="n">here</span> <span class="p">,</span> <span class="n">n&#39;</span> <span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">xs</span> <span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
</span><span class='line'>          <span class="p">(</span><span class="n">pcons</span> <span class="n">n&#39;</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">ih</span> <span class="p">)</span>
</span><span class='line'>          <span class="n">n</span> <span class="n">q</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">,</span> <span class="n">tt</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₁</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">proj</span><span class="err">₂</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>An Avalanche of Canonical Terms</h2>

<p>We have already seen how large the desugared code gets in the previous
section. Unfortunately, if you evaluate this code to canonical form it
gets much bigger! For example, the
<a href="https://gist.github.com/larrytheliquid/8447251#file-propositionaldescinductionconcat-agda">canonical term</a>
 for <code>concat</code> defined
using <code>ind</code> is <em>2,195</em> lines long! This is a huge term, considering
the
<a href="https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/Standard.agda#L36-L50">surface language source</a>
 for defining the types and values of <code>add</code>, <code>mult</code>, <code>append</code>, and
 <code>concat</code> is <em>14</em> lines long (the line count above only accounts for
 the value of concat by itself).</p>

<p>Some negative consequences of large canonical terms include:</p>

<ul>
<li>Computational overhead type checking expressions against these
canonical types.</li>
<li>Computational overhead embedding/pretty-printing these canonical
terms.</li>
<li>Memory overhead in type checking and embedding/pretty-printing.</li>
<li>Readability of canonical terms for developers while debugging.</li>
</ul>


<p>Some of this explosion in size comes from using eliminators instead of
dependent pattern matching, where the motive must be supplied
explicitly. Some more comes from the fact that a <code>μ</code> representing a
type is applied to its description, which may be large, so anywhere
the type appears the whole description is duplicated.</p>

<p>I haven&rsquo;t thought that much about solutions to this large term problem
yet, but I can imagine a few. I don&rsquo;t want to perform implicit
argument search and unification in the canonical type theory because
it complicates it too much. However, the current canonical grammar is
already broken up into values and spines. This allows for some
bidirectional argument synthesis for values, but not for elimination
rules. Breaking up the grammar further would allow for synthesis of
arguments to elimination rules too, and the canonical type checker
would remain relatively simple.
<a href="https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/InferredPropositionalDesc.agda">Here is a file</a>
that adds some implicit
arguments to the definitions presented thus far that I believe could
be synthesized. I didn&rsquo;t try that hard, so there is more room for
making things more implicit, but that at least takes the
<a href="https://gist.github.com/larrytheliquid/8447251#file-inferredpropositionaldescinductionconcat-agda">line count</a>
down to <em>1,411</em>.</p>

<p>An interesting thing to notice is that the way elimination proceeds
when writing definitions with <code>ind</code>, <code>case</code>, and <code>subst</code> is rather
uniform. All definitions of datatypes can already be characterized as
codes of a universe called <code>tagDesc</code> in Dagand <code>Definition 4.23</code>.
Dagand programs over this universe to perform generic programming. One form
of that would be a specialized <code>indcase</code> definition that automatically
applies <code>ind</code>, then
<code>case</code>, then maybe <code>subst</code> too. Ideally, I would like a generic
<code>elim</code> function that computes the exact type signature expected from
standard eliminators from each description. This basically involves
additionally doing some currying/uncurrying to pack/unpack values out of the tuple
produced by the interpretation function for descriptions. As we have
seen, programming definitions using the interface exposed by
eliminators leads to
<a href="https://github.com/spire/spire/blob/b4f467da96d5de9050f58b41ac10fd9a73ac84df/formalization/agda/Spire/Examples/Standard.agda#L56-L74">pretty short code</a>.
The motive is still there and descriptions are still duplicated in
every occurrence of <code>μ</code>, but we need to win this war by winning many
battles. However, even if you programmed this generic <code>elim</code> function
within the language, the canonical term it produces would be just as
big. It may be necessary to add <code>elim</code> as a canonical term primitive
instead, and we may not even need the more general <code>ind</code> or <code>case</code> if
our language never produces code in the more general form where <code>ind</code>
or <code>case</code> would be necessary.</p>

<p>Another technique might be to avoid expanding definitions where
possible. For example, if you have a unique hash represent the
description for a type, then testing the equality of terms using the
same hash value would work. However, I would need to be careful to
evaluate that hash to a concrete term during type checking,
a form of lazy evaluation. Memoization of previously type-checked
terms, and equality comparisons, would help a lot too because there
are a lot of duplicated terms.</p>

<h2>Sums</h2>

<p>Using a tag that indexes into an enumeration as the domain of a
dependent pair type is isomorphic to using a <code>Sum</code> type. This
alternative approach is taken by Bob Atkey in
<a href="https://github.com/bobatkey/foveran">Foveran</a>. Well, the isomorphism
is almost there. A tag for an enumeration lets you have named sums,
used because we care about the name of our constructors. There are a
variety of ways to accomplish this with sums, like making a new
sum-like type, or always making the first type of a sum be a
labelled type
(see
<a href="http://strictlypositive.org/view.ps.gz">The view from the left</a>
) and ending the chain of sums in <code>⊥</code> on the right. This would still
allow you to perform generic programming by having a list of tuples of
strings plus descriptions act as the universe of codes
(just like <code>tagDesc</code>), which gets interpreted as a description,
which gets interpreted as a sequence of sums of the form that I just
described. There are a number of pros and cons between the tag and sum
approach that I should study more closely, but I think a lot of the
duplication issues would come up in either case.</p>

<h2>Later</h2>

<p>That wraps up this week&rsquo;s blog post. I think a weekly schedule is good
for this kind of development blog, as it gives me enough time to come
up with material worth blogging about and enough time for interested
readers to keep up.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Unremarkable Type Checker]]></title>
    <link href="http://spire-lang.org/blog/2014/01/05/an-unremarkable-type-checker/"/>
    <updated>2014-01-05T15:03:57-08:00</updated>
    <id>http://spire-lang.org/blog/2014/01/05/an-unremarkable-type-checker</id>
    <content type="html"><![CDATA[<p>Since becoming a PhD student at Portland State,
<a href="https://twitter.com/larrytheliquid">I&rsquo;ve</a> been occasionally
hacking on what is currently a rather
<a href="https://github.com/spire/spire">boring type checker (by the name of Spire)</a>, but  what I hope
to become a dependently typed language for experimenting with generic
programming. Development has been slow and sporadic, so for the new
year I&rsquo;m going to try out this daily development blog.</p>

<!-- more -->


<h2>Goals</h2>

<p>My friend and colleague <a href="http://web.cecs.pdx.edu/~ntc2/">Nathan</a> is
also hacking on it nowadays. The goals of the project are as follows:</p>

<ul>
<li>To help the implementors learn how a dependent type checker works.</li>
<li>To end up with a platform for experimenting with dependently typed
generic programming.</li>
<li>To elaborate everything in the language to a core type theory.</li>
<li>To formalize the type checker of the core type theory.</li>
</ul>


<p>For the most part, this comes down to implementing selective pieces of
<a href="https://code.google.com/p/epigram/">Epigram</a>.
More specifically, we&rsquo;re following a lot of what
<a href="http://gallium.inria.fr/~pdagand/">Pierre Dagand</a> has wonderfully described
in his
<a href="http://gallium.inria.fr/~pdagand/stuffs/thesis-2011-phd/thesis.pdf">thesis</a>.</p>

<h2>Project Structure</h2>

<p>I experimented with a few different project structures, and my
favorite ended up using a canonical type theory for the core along
with hereditary substitution. I learned about hereditary substitution
from a beautiful paper describing how to formalize termination of
evaluation for the STLC by
<a href="http://www.cs.nott.ac.uk/~txa/publ/msfp10.pdf">Keller and Alternkirch</a>.
The technique originally came out work on the metatheory of LF/Twelf.
<a href="http://www.cs.cmu.edu/~cmartens/lfinlf.pdf">Martens and Crary</a> have a
nice modern paper on how to use this to formalize LF in LF.</p>

<p>In a canonical type theory your terms are grammatically enforced to be
in β-normal form. This has a number of desirable consequences, for
instance:</p>

<ul>
<li>Big-step semantics (evaluation) can go from expressions to canonical
terms, ensuring that you did not forget to reduce any β-redex.</li>
<li>A type-checking function checks expressions against reduced
types. If the reduced types are canonical terms, you don&rsquo;t need to
check for and throw errors due to expressions containing redexes.</li>
<li>Other algorithms, such as unification, also benefit from operating
on canonical terms, especially if they are in spine form where the
variable that eliminators are stuck on is easily accessible. For
instance,
<a href="https://personal.cis.strath.ac.uk/adam.gundry/thesis/">Adam Gundry</a>
implements his dependently typed unification this way.</li>
</ul>


<p>Because so many algorithms in a dependently typed language take or
return redex-free terms, having a canonical type theory makes things
easier and less error prone. Canonical terms are no
longer closed under substitution, hence <em>hereditary substitution</em>
evaluates as it substitutes to remove redexes.</p>

<p>I originally tried to implement canonical Spire in Agda, extending
Keller and Altenkirch&rsquo;s typed STLC terms to dependent types. In Twelf
the canonical type theory even makes termination of hereditary
substitution immediate. However, Twelf&rsquo;s termination argument does not
easily extend to dependent type theory with
large eliminations (functions that return types). Even if you turn off
the termination checker, getting the rest of the definitions to type
check is difficult because of the multitude of mutual definitions.
<a href="https://github.com/spire/spire/blob/master/formalization/agda/Spire/Operational.agda">Here is a file</a>
that postulates the hereditary substitution function, but still
defines all the other semantic functions that would be used when
implementing hereditary substitution. Somewhere on my hard drive
exists a stuck attempt at defining substitution where I ran into
trouble with all the mutual definitions.</p>

<p>In any case, making the typed-syntax above pass type checking would
still leave the open problem of termination. Instead, Spire is
implemented in Haskell with untyped syntax and a partial (monadic)
hereditary substitution semantics. I&rsquo;m working on trying to prove
termination of this untyped semantics in Agda, which is easier due to not
having so many mutual definitions, and many future blog posts will
cover my slow progress on that front.</p>

<h2>Where Were We?</h2>

<p>Ah yes, so the project structure of Spire. The idea is to have a
surface syntax of high-level constructs and expressions that
elaborates to the closed core type theory. This idea is the hallmark of
Epigram. Examples of this include Conor McBride&rsquo;s work on
<a href="http://strictlypositive.org/goguen.pdf">compiling dependent pattern matching to eliminators</a>,
and Pierre Dagand&rsquo;s work on compiling
<a href="http://gallium.inria.fr/~pdagand/stuffs/paper-2012-data-jfla/paper.pdf">data declarations to descriptions</a>.
Dagand&rsquo;s
<a href="http://gallium.inria.fr/~pdagand/stuffs/thesis-2011-phd/thesis.pdf">thesis</a>
describes this process well. A minor difference is that we are
elaborating to canonical terms rather than a core theory that includes
expressions. The metatheorem for soundness of elaboration described
by Dagand corresponds to type preservation: After elaboration of a
well-typed surface term, you get a well-typed core term. In the
eventually formalized Spire canonical type theory, this will be
proven. In the current Haskell version, this is
<a href="https://github.com/spire/spire/blob/f948548c4b5793fdc042989404f4aad49a5015cc/src/Spire/Pipeline.hs#L29">dynamically checked</a>
rather than proven.</p>

<p>Spire is currently split into 3 languages. The top language called
<a href="https://github.com/spire/spire/blob/f948548c4b5793fdc042989404f4aad49a5015cc/src/Spire/Surface/Types.hs">Surface</a>
is what the user programs in. Elaboration from surface proceeds to
<a href="https://github.com/spire/spire/blob/f948548c4b5793fdc042989404f4aad49a5015cc/src/Spire/Expression/Types.hs">Expression</a>.
Expressions are like surface terms, but contain a two-part bidirectional
syntax. Other syntactical elaborations (those that need not be type directed) will also be performed here
in the future. Nathan has been working on the implicit arguments front
of the project, and Spire currently supports wildcard arguments.
Elaboration from Syntax to Expression also removes wildcards and
introduces metavariables into the context. In the future Surface will
contain other high-level constructrs like data declarations and
pattern matching syntax. Eloboration proceeds from expressions to
<a href="https://github.com/spire/spire/blob/master/src/Spire/Canonical/Types.hs">Canonical</a>
terms. This performs type checking, introduces and solves unification
problems, and removes β-redexes. To keep the canonical terms smaller,
we only require them to be checkable rather than
inferrable/synthesizable. Canonical terms can be checked
bidirectionally, as they are already grammatically split into Values
and neutrals/spines. This works so long as every eliminator only
eliminates something inferred and the rest of the arguments are
checkable. A counter-example of this is the <code>if</code>-statement helper in
Expression. Therein the types of the two branches need to be inferred
rather than checked, but <code>if</code> appears as a specialized <code>elimBool</code> in
the canonical theory (once we have full implicit argument support,
<code>if</code> can go away in expressions too, but this is a nice example of what
would break bidirectional canonical type checking). Finally,
there are embedding functions to go back up the chain of languages. Another
<a href="https://github.com/spire/spire/blob/f948548c4b5793fdc042989404f4aad49a5015cc/src/Spire/Pipeline.hs#L30">metatheorem</a>
that appears as a dynamic check in Spire is: if you evaluate a
well-typed term to a canonical, then embed it back up to a surface
term and evaluate it again, you get back the same canonical term. This
becomes more important as the surface and canonical languages diverge
more. Embedding is used to pretty-print canonicals after evaluation,
for example in error messages. Although messing up embedding does not
affect consistency, as a practical matter it would confuse the user if
type errors contained the wrong terms due to embedding bugs!</p>

<h3>Implicit Arguments</h3>

<p>The implicit argument work by Nathan (I&rsquo;ll ask him if he wants to
describe it) was inspired by <a href="http://arxiv.org/abs/1202.4905">Asperti et. al.&rsquo;s Matita work</a>
and somewhat by
<a href="http://eb.host.cs.st-andrews.ac.uk/drafts/impldtp.pdf">Edwin Brady&rsquo;s Idris work</a>. It
relies on the higher-order unification algorithm and library by
<a href="https://github.com/adamgundry/type-inference">Gundry</a>, and currently
translates between Spire terms and Gundry terms.</p>

<h3>Substitution &amp; Binding</h3>

<p>With something like NbE in
<a href="http://www.andres-loeh.de/LambdaPi/">Lambda Pi</a>
you get to inherit  binding
structure and substitution from the meta-language. In Spire binding must be implemented
directly, but thanks to the
<a href="http://hackage.haskell.org/package/unbound">Unbound</a> library a lot of
this can be automated. We also added a
<a href="https://github.com/spire/substM">monadic extension</a>
that makes it possible to
use Unbound for hereditary substitution, used like
<a href="https://github.com/spire/spire/blob/f948548c4b5793fdc042989404f4aad49a5015cc/src/Spire/Canonical/Evaluator.hs#L23">this</a>
in Spire.</p>

<h2>Wrapping Up</h2>

<p>My near term next steps are going to be adding <code>Desc</code>riptions and implementing Dagand&rsquo;s data
declaration elaboration work, as well as working on trying to
formalize termination of Spire&rsquo;s canonical theory. We&rsquo;re leaving
type-in-type in the Haskell code for now, as I&rsquo;m
<a href="https://github.com/larrytheliquid/leveling-up">comfortable enough</a>
with universe hierarchies now to add them later (famous last words).
That&rsquo;s it for now folks, see you tomorrow with the start of a nice new
term. Also, Nathan and I have started to idle in <code>#spire-lang</code> on
<code>freenode</code>, so feel free to idle alongside us.</p>
]]></content>
  </entry>
  
</feed>
